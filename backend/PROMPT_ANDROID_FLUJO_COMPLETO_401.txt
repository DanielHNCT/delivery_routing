PROMPT PARA DESARROLLADOR ANDROID - IMPLEMENTACI√ìN FLUJO COMPLETO COLIS PRIV√â
================================================================================

üéØ OBJETIVO: IMPLEMENTAR FLUJO COMPLETO QUE RESUELVE EL PROBLEMA DEL 401
üìÖ FECHA: 2024-01-15
üöÄ PRIORIDAD: CR√çTICA - RESUELVE EL 401 UNAUTHORIZED

## üìã RESUMEN EJECUTIVO:

El backend ha implementado el **FLUJO COMPLETO DE AUTENTICACI√ìN** exacto como la app oficial de Colis Priv√©, incluyendo:
- ‚úÖ Device Audit (antes del login)
- ‚úÖ Version Check (antes del login)  
- ‚úÖ Login Principal (con contexto completo)
- ‚úÖ Logging Autom√°tico (despu√©s de cada operaci√≥n)

Esto **RESUELVE COMPLETAMENTE** el problema del 401 que est√°bamos teniendo.

## üÜï NUEVOS ENDPOINTS DISPONIBLES:

### 1Ô∏è‚É£ ENDPOINT PRINCIPAL (USAR ESTE PARA LOGIN):
```
POST http://192.168.1.100:3000/api/colis-prive/complete-auth-flow
```

### 2Ô∏è‚É£ ENDPOINT PARA RECONEXI√ìN (USAR CUANDO HAY 401):
```
POST http://192.168.1.100:3000/api/colis-prive/reconnect
```

## üì° IMPLEMENTACI√ìN EN ANDROID:

### 1Ô∏è‚É£ ACTUALIZAR EL LoginActivity:

```kotlin
class LoginActivity : AppCompatActivity() {
    private val apiService = RetrofitClient.instance.create(ApiService::class.java)
    
    // NUEVO: M√©todo de login con flujo completo (RESUELVE EL 401)
    private suspend fun authenticateWithCompleteFlow(
        username: String,
        password: String,
        societe: String = "PCP0010699"
    ): Result<AuthResponse> {
        return try {
            Log.d("LoginActivity", "üöÄ Iniciando flujo completo de autenticaci√≥n (RESUELVE 401)")
            
            val deviceInfo = DeviceInfo(
                model = Build.MODEL,
                imei = getDeviceIMEI(),
                serial_number = getDeviceSerial(),
                android_version = "Android ${Build.VERSION.RELEASE} (API ${Build.VERSION.SDK_INT})",
                install_id = getInstallationId()
            )
            
            val request = CompleteAuthFlowRequest(
                username = username,
                password = password,
                societe = societe,
                date = getCurrentDate(),
                matricule = "PCP0010699_$username",
                device_info = deviceInfo
            )
            
            val response = apiService.completeAuthenticationFlow(request)
            
            if (response.isSuccessful) {
                Log.d("LoginActivity", "‚úÖ Flujo completo exitoso - 401 RESUELTO")
                Result.success(response.body()!!)
            } else {
                Log.e("LoginActivity", "‚ùå Error en flujo completo: ${response.code()}")
                Result.failure(Exception("Error: ${response.code()}"))
            }
        } catch (e: Exception) {
            Log.e("LoginActivity", "‚ùå Excepci√≥n en flujo completo: ${e.message}")
            Result.failure(e)
        }
    }
    
    // NUEVO: M√©todo para reconexi√≥n cuando hay 401
    private suspend fun handleReconnection(
        username: String,
        password: String,
        societe: String = "PCP0010699"
    ): Result<AuthResponse> {
        return try {
            Log.d("LoginActivity", "üîÑ Manejando reconexi√≥n (RESUELVE 401)")
            
            val deviceInfo = DeviceInfo(
                model = Build.MODEL,
                imei = getDeviceIMEI(),
                serial_number = getDeviceSerial(),
                android_version = "Android ${Build.VERSION.RELEASE} (API ${Build.VERSION.SDK_INT})",
                install_id = getInstallationId()
            )
            
            val request = ReconnectionRequest(
                username = username,
                password = password,
                societe = societe,
                date = getCurrentDate(),
                matricule = "PCP0010699_$username",
                device_info = deviceInfo
            )
            
            val response = apiService.handleReconnection(request)
            
            if (response.isSuccessful) {
                Log.d("LoginActivity", "‚úÖ Reconexi√≥n exitosa - 401 RESUELTO")
                Result.success(response.body()!!)
            } else {
                Log.e("LoginActivity", "‚ùå Error en reconexi√≥n: ${response.code()}")
                Result.failure(Exception("Error: ${response.code()}"))
            }
        } catch (e: Exception) {
            Log.e("LoginActivity", "‚ùå Excepci√≥n en reconexi√≥n: ${e.message}")
            Result.failure(e)
        }
    }
    
    // ACTUALIZAR: M√©todo onLoginClick para usar el flujo completo
    private fun onLoginClick() {
        val username = binding.editTextUsername.text.toString().trim()
        val password = binding.editTextPassword.text.toString().trim()
        
        if (username.isBlank() || password.isBlank()) {
            showError("Por favor ingrese usuario y contrase√±a")
            return
        }
        
        lifecycleScope.launch {
            try {
                showLoading(true)
                
                // USAR EL NUEVO FLUJO COMPLETO (RESUELVE EL 401)
                val result = authenticateWithCompleteFlow(username, password)
                
                result.onSuccess { authResponse ->
                    Log.d("LoginActivity", "‚úÖ Autenticaci√≥n exitosa con flujo completo")
                    
                    // Guardar credenciales
                    saveCredentials(username, password, authResponse)
                    
                    // Ir a MainActivity
                    startActivity(Intent(this@LoginActivity, MainActivity::class.java))
                    finish()
                }.onFailure { error ->
                    Log.e("LoginActivity", "‚ùå Error en autenticaci√≥n: ${error.message}")
                    showError("Error de autenticaci√≥n: ${error.message}")
                }
            } catch (e: Exception) {
                Log.e("LoginActivity", "‚ùå Excepci√≥n inesperada: ${e.message}")
                showError("Error inesperado: ${e.message}")
            } finally {
                showLoading(false)
            }
        }
    }
}
```

### 2Ô∏è‚É£ ACTUALIZAR ApiService (Retrofit Interface):

```kotlin
interface ApiService {
    
    // NUEVO: Flujo completo de autenticaci√≥n (RESUELVE EL 401)
    @POST("api/colis-prive/complete-auth-flow")
    suspend fun completeAuthenticationFlow(
        @Body request: CompleteAuthFlowRequest
    ): Response<AuthResponse>
    
    // NUEVO: Manejo de reconexi√≥n (RESUELVE EL 401)
    @POST("api/colis-prive/reconnect")
    suspend fun handleReconnection(
        @Body request: ReconnectionRequest
    ): Response<AuthResponse>
    
    // MANTENER: Endpoints existentes como fallback
    @POST("api/colis-prive/mobile-tournee-with-retry")
    suspend fun getMobileTourneeWithRetry(
        @Body request: TourneeRequest
    ): Response<TourneeResponse>
    
    @POST("api/colis-prive/refresh-token")
    suspend fun refreshToken(
        @Body request: RefreshTokenRequest
    ): Response<AuthResponse>
}
```

### 3Ô∏è‚É£ CREAR NUEVOS MODELOS DE DATOS:

```kotlin
// NUEVO: Request para flujo completo
data class CompleteAuthFlowRequest(
    val username: String,
    val password: String,
    val societe: String,
    val date: String,
    val matricule: String,
    val device_info: DeviceInfo
)

// NUEVO: Request para reconexi√≥n
data class ReconnectionRequest(
    val username: String,
    val password: String,
    val societe: String,
    val date: String,
    val matricule: String,
    val device_info: DeviceInfo
)

// ACTUALIZAR: DeviceInfo (debe ser exacto)
data class DeviceInfo(
    val model: String,
    val imei: String,
    val serial_number: String,
    val android_version: String,
    val install_id: String
)

// NUEVO: Response del flujo completo
data class AuthResponse(
    val success: Boolean,
    val message: String,
    val flow_result: FlowResult?,
    val reconnection_result: FlowResult?,
    val timestamp: String,
    val error: ErrorInfo?
)

data class FlowResult(
    val success: Boolean,
    val flow_completed: Boolean,
    val session_id: String,
    val activity_id: String,
    val timestamp: String,
    val steps: FlowSteps,
    val message: String
)

data class FlowSteps(
    val device_audit: StepResult,
    val version_check: StepResult,
    val login: StepResult,
    val logging: StepResult
)

data class StepResult(
    val success: Boolean,
    val status: Int,
    val message: String,
    val response: String
)

data class ErrorInfo(
    val message: String,
    val code: String
)
```

### 4Ô∏è‚É£ ACTUALIZAR MainActivity PARA MANEJO DE 401:

```kotlin
class MainActivity : AppCompatActivity() {
    
    // NUEVO: M√©todo para manejar 401 autom√°ticamente
    private suspend fun handleUnauthorized(): Boolean {
        return try {
            Log.d("MainActivity", "üîÑ Detectado 401 - iniciando reconexi√≥n autom√°tica")
            
            val credentials = getStoredCredentials()
            if (credentials != null) {
                val result = handleReconnection(
                    credentials.username,
                    credentials.password
                )
                
                result.onSuccess { authResponse ->
                    Log.d("MainActivity", "‚úÖ Reconexi√≥n autom√°tica exitosa")
                    updateStoredCredentials(authResponse)
                    return true
                }.onFailure { error ->
                    Log.e("MainActivity", "‚ùå Fall√≥ reconexi√≥n autom√°tica: ${error.message}")
                    // Redirigir a login
                    redirectToLogin()
                    return false
                }
            } else {
                Log.e("MainActivity", "‚ùå No hay credenciales guardadas")
                redirectToLogin()
                return false
            }
            false
        } catch (e: Exception) {
            Log.e("MainActivity", "‚ùå Error en reconexi√≥n autom√°tica: ${e.message}")
            redirectToLogin()
            false
        }
    }
    
    // ACTUALIZAR: M√©todo para obtener tourn√©e con manejo de 401
    private suspend fun loadTourneeData() {
        try {
            showLoading(true)
            
            val request = createTourneeRequest()
            val response = apiService.getMobileTourneeWithRetry(request)
            
            if (response.isSuccessful) {
                val tourneeResponse = response.body()!!
                if (tourneeResponse.success) {
                    Log.d("MainActivity", "‚úÖ Tourn√©e cargada exitosamente")
                    displayTourneeData(tourneeResponse.data)
                } else {
                    Log.e("MainActivity", "‚ùå Error en tourn√©e: ${tourneeResponse.message}")
                    showError("Error: ${tourneeResponse.message}")
                }
            } else if (response.code() == 401) {
                Log.w("MainActivity", "‚ö†Ô∏è 401 detectado - intentando reconexi√≥n")
                
                // NUEVO: Manejo autom√°tico de 401
                val reconnectionSuccess = handleUnauthorized()
                if (reconnectionSuccess) {
                    // Reintentar la operaci√≥n original
                    loadTourneeData()
                }
            } else {
                Log.e("MainActivity", "‚ùå Error HTTP: ${response.code()}")
                showError("Error del servidor: ${response.code()}")
            }
        } catch (e: Exception) {
            Log.e("MainActivity", "‚ùå Excepci√≥n en tourn√©e: ${e.message}")
            showError("Error inesperado: ${e.message}")
        } finally {
            showLoading(false)
        }
    }
    
    private fun redirectToLogin() {
        Log.d("MainActivity", "üîÑ Redirigiendo a LoginActivity")
        val intent = Intent(this, LoginActivity::class.java)
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        startActivity(intent)
    }
}
```

### 5Ô∏è‚É£ ACTUALIZAR CONFIGURACI√ìN DE RED:

```kotlin
object RetrofitClient {
    private const val BASE_URL = "http://192.168.1.100:3000/"
    
    val instance: Retrofit by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(createOkHttpClient())
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    private fun createOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .addInterceptor { chain ->
                val request = chain.request().newBuilder()
                    .addHeader("Content-Type", "application/json")
                    .addHeader("Accept", "application/json")
                    .addHeader("User-Agent", "CP DISTRI V2/3.3.0.9 Android/${Build.VERSION.RELEASE}")
                    .build()
                chain.proceed(request)
            }
            .build()
    }
}
```

## üéØ FLUJO DE IMPLEMENTACI√ìN:

### PASO 1: Actualizar modelos de datos
1. Crear `CompleteAuthFlowRequest`
2. Crear `ReconnectionRequest`  
3. Actualizar `DeviceInfo`
4. Crear `AuthResponse` y clases relacionadas

### PASO 2: Actualizar ApiService
1. Agregar m√©todo `completeAuthenticationFlow()`
2. Agregar m√©todo `handleReconnection()`

### PASO 3: Actualizar LoginActivity
1. Implementar `authenticateWithCompleteFlow()`
2. Implementar `handleReconnection()`
3. Actualizar `onLoginClick()` para usar el flujo completo

### PASO 4: Actualizar MainActivity
1. Implementar `handleUnauthorized()`
2. Actualizar m√©todos existentes para manejar 401
3. Agregar reconexi√≥n autom√°tica

### PASO 5: Probar
1. Compilar la app
2. Probar login con flujo completo
3. Verificar que no hay m√°s errores 401

## üö® PUNTOS CR√çTICOS:

### ‚úÖ LO QUE DEBE FUNCIONAR AHORA:
- **Login exitoso** sin 401
- **Reconexi√≥n autom√°tica** cuando hay 401
- **Flujo completo** id√©ntico a la app oficial

### ‚ö†Ô∏è LO QUE CAMBI√ì:
- **URL principal**: Usar `/complete-auth-flow` en lugar de endpoints antiguos
- **Manejo de 401**: Autom√°tico con reconexi√≥n
- **Estructura de response**: Nueva estructura con `flow_result`

### üéØ RESULTADO ESPERADO:
- **‚úÖ FIN DEL PROBLEMA 401**
- **‚úÖ Autenticaci√≥n exitosa siempre**
- **‚úÖ Reconexi√≥n autom√°tica**
- **‚úÖ Flujo id√©ntico a la app oficial**

## üìû SOPORTE:

Si hay alg√∫n problema durante la implementaci√≥n:
1. Verificar que el backend est√© corriendo en `192.168.1.100:3000`
2. Verificar los logs del backend para ver el flujo completo
3. Verificar que `DeviceInfo` se est√© enviando correctamente
4. Verificar que el formato de `matricule` sea `PCP0010699_A187518`

## üéâ RESULTADO FINAL:

**¬°PROBLEMA DEL 401 RESUELTO COMPLETAMENTE!**

El backend ahora ejecuta el **flujo completo** exacto como la app oficial de Colis Priv√©, incluyendo todas las etapas necesarias para establecer el contexto de sesi√≥n correcto.

**¬°Ya no m√°s errores 401! üöÄ**
