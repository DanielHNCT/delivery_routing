üîç REPORTE DETALLADO DEL C√ìDIGO BACKEND - AN√ÅLISIS PROBLEMA 401

üìã INFORMACI√ìN DEL SISTEMA
==========================
Backend: Rust + Axum corriendo en Pi 5 (IP: 192.168.1.9:3000)
API: Colis Priv√© Web API (no m√≥vil)
Estado: Funcionando correctamente, comunicaci√≥n establecida
Fecha de an√°lisis: 28 de Agosto 2025, 20:45 CEST

1. ARCHIVO src/api/colis_prive.rs - FUNCIONES COMPLETAS
========================================================

‚úÖ FUNCI√ìN DE AUTENTICACI√ìN COMPLETA:
====================================

/// POST /api/colis-prive/auth - Autenticar con Colis Priv√©
pub async fn authenticate_colis_prive(
    State(_state): State<AppState>,
    Json(credentials): Json<ColisPriveAuthRequest>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    // Clonar las credenciales para poder usarlas despu√©s
    let username = credentials.username.clone();
    let societe = credentials.societe.clone();
    
    match ColisPriveService::authenticate_colis_prive(credentials).await {
        Ok(response) => {
            if response.success {
                let auth_response = json!({
                    "success": true,
                    "authentication": {
                        "token": response.token,
                        "matricule": response.matricule,
                        "message": response.message
                    },
                    "credentials_used": {
                        "username": username,
                        "societe": societe
                    },
                    "timestamp": chrono::Utc::now().to_rfc3339()
                });
                Ok(Json(auth_response))
            } else {
                let error_response = json!({
                    "success": false,
                    "error": {
                        "message": response.message,
                        "code": "AUTH_FAILED"
                    },
                    "credentials_used": {
                        "username": username,
                        "societe": societe
                    },
                    "timestamp": chrono::Utc::now().to_rfc3339()
                });
                Ok(Json(error_response))
            }
        }
        Err(e) => {
            tracing::error!("Error en autenticaci√≥n Colis Priv√©: {}", e);
            let error_response = json!({
                "success": false,
                "error": {
                    "message": format!("Error interno del servidor: {}", e),
                    "code": "INTERNAL_ERROR"
                },
                "timestamp": chrono::Utc::now().to_rfc3339()
            });
            Ok(Json(error_response))
        }
    }
}

‚úÖ FUNCI√ìN AUXILIAR DE AUTENTICACI√ìN SIMPLE:
============================================

async fn authenticate_colis_prive_simple(
    credentials: &ColisPriveAuthRequest
) -> Result<ColisPriveAuthResponse, anyhow::Error> {
    log::info!("üîê Autenticando con Colis Priv√© (modo real)");
    
    // Validar credenciales b√°sicas
    if credentials.username.is_empty() || credentials.password.is_empty() || credentials.societe.is_empty() {
        anyhow::bail!("Credenciales incompletas");
    }
    
    // üîß IMPLEMENTACI√ìN REAL: Autenticaci√≥n directa con Colis Priv√©
    let login_field = format!("{}_{}", credentials.societe, credentials.username);
    
    let auth_url = "https://wsauthentificationexterne.colisprive.com/";
    let auth_payload = json!({
        "commun": {
            "dureeTokenInHour": 24
        },
        "login": login_field,
        "password": credentials.password,
        "societe": credentials.societe
    });
    
    log::info!("üì§ Enviando autenticaci√≥n a: {}", auth_url);
    log::info!("üîë Login field: {}", login_field);
    
    let auth_response = reqwest::Client::new()
        .post(auth_url)
        .header("Accept", "application/json, text/plain, */*")
        .header("Accept-Language", "fr-FR,fr;q=0.5")
        .header("Cache-Control", "no-cache")
        .header("Content-Type", "application/json")
        .header("Origin", "https://gestiontournee.colisprive.com")
        .header("Referer", "https://gestiontournee.colisprive.com/")
        .header("User-Agent", "DeliveryRouting/1.0")
        .json(&auth_payload)
        .send()
        .await
        .map_err(|e| {
            log::error!("‚ùå Error de conexi√≥n con Colis Priv√©: {}", e);
            anyhow::anyhow!("Error de conexi√≥n: {}", e)
        })?;
    
    if !auth_response.status().is_success() {
        let error_text = auth_response.text().await.unwrap_or_default();
        log::error!("‚ùå Colis Priv√© respondi√≥ con error: {}", error_text);
        anyhow::bail!("Error de autenticaci√≥n: {}", error_text);
    }
    
    let auth_text = auth_response.text().await.map_err(|e| {
        log::error!("‚ùå Error leyendo respuesta de autenticaci√≥n: {}", e);
        anyhow::anyhow!("Error leyendo respuesta: {}", e)
    })?;
    
    log::info!("üì• Respuesta de autenticaci√≥n recibida: {}", &auth_text[..auth_text.len().min(200)]);
    
    // Parsear la respuesta de Colis Priv√©
    let auth_data: serde_json::Value = serde_json::from_str(&auth_text).map_err(|e| {
        log::error!("‚ùå Error parseando respuesta de autenticaci√≥n: {}", e);
        anyhow::anyhow!("Error parseando respuesta: {}", e)
    })?;
    
    // Extraer el token SsoHopps real
    let sso_hopps = auth_data.get("SsoHopps")
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow::anyhow!("Token SsoHopps no encontrado en la respuesta"))?;
    
    log::info!("‚úÖ Token SsoHopps obtenido exitosamente");
    
    let auth_response = ColisPriveAuthResponse {
        success: true,
        message: "Autenticaci√≥n exitosa con Colis Priv√©".to_string(),
        token: Some(sso_hopps.to_string()),
        matricule: Some(credentials.username.clone()),
    };
    
    Ok(auth_response)
}

‚ùå FUNCI√ìN DE TOURN√âE (PROBLEM√ÅTICA):
======================================

/// GET /api/colis-prive/tournee - Obtener tourn√©e (SIMPLIFICADO PARA WEB)
pub async fn get_tournee_data(
    State(_state): State<AppState>,
    Json(request): Json<GetTourneeRequest>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    log::info!("üîÑ Obteniendo tourn√©e para: {}", request.matricule);
    
    // ‚úÖ SOLO FUNCIONA CON API WEB - NO REQUIERE DEVICE_INFO
    // En el futuro implementaremos la versi√≥n mobile
    
    // Crear credenciales para el servicio
    let credentials = ColisPriveAuthRequest {
        username: request.username.clone(),
        password: request.password.clone(),
        societe: request.societe.clone(),
    };

    // üîß IMPLEMENTACI√ìN SIMPLIFICADA: Solo autenticaci√≥n b√°sica
    match authenticate_colis_prive_simple(&credentials).await {
        Ok(auth_response) => {
            log::info!("‚úÖ Autenticaci√≥n exitosa para tourn√©e");
            
            // Crear respuesta simplificada
            let response = json!({
                "success": true,
                "message": "Tourn√©e obtenido exitosamente (modo web)",
                "data": {
                    "SsoHopps": auth_response.token,
                    "matricule": request.matricule,
                    "societe": request.societe,
                    "date": request.date,
                    "api_type": "web"
                },
                "metadata": {
                    "date": request.date,
                    "matricule": request.matricule,
                    "username": request.username,
                    "societe": request.societe,
                    "note": "Endpoint simplificado - solo modo web"
                },
                "timestamp": chrono::Utc::now().to_rfc3339()
            });

            Ok(Json(response))
        }
        Err(e) => {
            log::error!("‚ùå Error en tourn√©e: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

2. ARCHIVO src/services/colis_prive_service.rs - STRUCTS
========================================================

‚úÖ STRUCTS DE AUTENTICACI√ìN:
============================

/// Request de autenticaci√≥n para Colis Priv√©
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ColisPriveAuthRequest {
    pub username: String,
    pub password: String,
    pub societe: String,
}

/// Response de autenticaci√≥n de Colis Priv√©
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ColisPriveAuthResponse {
    pub success: bool,
    pub message: String,
    pub token: Option<String>,
    pub matricule: Option<String>,
}

‚úÖ STRUCTS DE TOURN√âE:
======================

/// Request para obtener tourn√©e
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTourneeRequest {
    pub username: String,
    pub password: String,
    pub societe: String,
    pub matricule: String,
}

3. ARCHIVO src/external_models.rs - MODELOS EXTERNOS
====================================================

‚úÖ MODELOS DE AUTENTICACI√ìN WEB:
================================

#[derive(Debug, Serialize, Deserialize)]
pub struct ColisPriveWebAuthRequest {
    pub login: String,
    pub password: String,
    pub societe: String,
    pub commun: Commun,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ColisPriveWebAuthResponse {
    pub isAuthentif: bool,
    pub identity: String,
    pub matricule: String,
    pub societe: String,
    pub tokens: ColisPriveTokens,
    pub roles: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ColisPriveTokens {
    pub SsoHopps: String,
}

‚úÖ MODELOS DE TOURN√âE WEB:
==========================

#[derive(Debug, Serialize, Deserialize)]
pub struct ColisPriveWebTourneeRequest {
    pub Societe: String,
    pub Matricule: String,
    pub DateDebut: String,
    pub Agence: Option<String>,
    pub Concentrateur: Option<String>,
}

4. FLUJO DE TOKEN - AN√ÅLISIS DETALLADO
========================================

üîç PROBLEMA IDENTIFICADO:
=========================

EL TOKEN SE OBTIENE CORRECTAMENTE EN LA AUTENTICACI√ìN, PERO NO SE EST√Å USANDO EN LA PETICI√ìN DE TOURN√âE.

‚úÖ FLUJO DE AUTENTICACI√ìN (FUNCIONA):
=====================================

1. Endpoint: POST /api/colis-prive/auth
2. Funci√≥n: authenticate_colis_prive()
3. Proceso:
   - Recibe credenciales (username, password, societe)
   - Llama a authenticate_colis_prive_simple()
   - Hace petici√≥n HTTP a Colis Priv√© con headers correctos
   - Recibe respuesta con token SsoHopps
   - Devuelve token en .authentication.token

4. Headers enviados a Colis Priv√©:
   - Accept: "application/json, text/plain, */*"
   - Accept-Language: "fr-FR,fr;q=0.5"
   - Cache-Control: "no-cache"
   - Content-Type: "application/json"
   - Origin: "https://gestiontournee.colisprive.com"
   - Referer: "https://gestiontournee.colisprive.com/"
   - User-Agent: "DeliveryRouting/1.0"

‚ùå FLUJO DE TOURN√âE (FALLA):
=============================

1. Endpoint: POST /api/colis-prive/tournee
2. Funci√≥n: get_tournee_data()
3. Proceso PROBLEM√ÅTICO:
   - Recibe request con username, password, societe, matricule
   - Llama a authenticate_colis_prive_simple() NUEVAMENTE
   - Obtiene un NUEVO token (no usa el del paso anterior)
   - NO hace petici√≥n HTTP a Colis Priv√© para tourn√©e
   - Devuelve respuesta mock con el token

4. PROBLEMAS IDENTIFICADOS:
   - ‚ùå No usa el token del paso de autenticaci√≥n
   - ‚ùå Hace autenticaci√≥n duplicada
   - ‚ùå No env√≠a petici√≥n real a Colis Priv√© para tourn√©e
   - ‚ùå No env√≠a headers de autorizaci√≥n
   - ‚ùå Respuesta es mock, no datos reales

5. CONFIGURACI√ìN HTTP CLIENT - AN√ÅLISIS
========================================

üîç CONFIGURACI√ìN ACTUAL:
========================

‚úÖ CLIENTE DE AUTENTICACI√ìN:
- reqwest::Client::new()
- Headers personalizados implementados
- Timeout impl√≠cito por defecto
- No configuraci√≥n de compresi√≥n expl√≠cita

‚ùå CLIENTE DE TOURN√âE:
- NO EXISTE - No se hace petici√≥n HTTP real
- Solo se hace autenticaci√≥n interna
- No se usan headers de autorizaci√≥n

6. AN√ÅLISIS DEL PROBLEMA 401 - COMPARACI√ìN CON CURL
====================================================

üîç HEADERS FUNCIONALES DE CURL (REQUERIDOS):
============================================

Accept: "application/json, text/plain, */*"
Accept-Encoding: "gzip, deflate, br, zstd"
Accept-Language: "fr-FR,fr;q=0.5"
Cache-Control: "no-cache"
Connection: "keep-alive"
Content-Type: "application/json"
Origin: "https://gestiontournee.colisprive.com"
Referer: "https://gestiontournee.colisprive.com/"
User-Agent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36"

üîç HEADERS ACTUALES DEL BACKEND:
================================

‚úÖ AUTENTICACI√ìN (CORRECTO):
- Accept: "application/json, text/plain, */*" ‚úÖ
- Accept-Language: "fr-FR,fr;q=0.5" ‚úÖ
- Cache-Control: "no-cache" ‚úÖ
- Content-Type: "application/json" ‚úÖ
- Origin: "https://gestiontournee.colisprive.com" ‚úÖ
- Referer: "https://gestiontournee.colisprive.com/" ‚úÖ
- User-Agent: "DeliveryRouting/1.0" ‚ùå (deber√≠a ser browser-like)

‚ùå TOURN√âE (FALTANTES):
- NO SE ENV√çAN HEADERS - No hay petici√≥n HTTP real
- NO SE ENV√çA TOKEN - No hay autorizaci√≥n
- NO SE IMPLEMENTA ENDPOINT REAL

7. IDENTIFICACI√ìN ESPEC√çFICA DEL PROBLEMA
==========================================

üéØ PROBLEMA PRINCIPAL:
======================

LA FUNCI√ìN get_tournee_data() NO IMPLEMENTA LA PETICI√ìN HTTP REAL A COLIS PRIV√â PARA OBTENER TOURN√âE.

üîç AN√ÅLISIS DEL C√ìDIGO:
========================

1. **Funci√≥n authenticate_colis_prive_simple()**: ‚úÖ IMPLEMENTADA CORRECTAMENTE
   - Hace petici√≥n HTTP real a Colis Priv√©
   - Env√≠a headers correctos
   - Procesa respuesta y extrae token

2. **Funci√≥n get_tournee_data()**: ‚ùå IMPLEMENTACI√ìN INCOMPLETA
   - Solo llama a authenticate_colis_prive_simple()
   - No hace petici√≥n HTTP para tourn√©e
   - Devuelve respuesta mock
   - No usa el token para autorizaci√≥n

üîß SOLUCI√ìN REQUERIDA:
======================

IMPLEMENTAR LA PETICI√ìN HTTP REAL A COLIS PRIV√â EN get_tournee_data():

1. **Usar el token del paso de autenticaci√≥n**
2. **Hacer petici√≥n HTTP real a endpoint de tourn√©e**
3. **Enviar headers de autorizaci√≥n con el token**
4. **Procesar respuesta real de Colis Priv√©**
5. **Implementar headers exactos requeridos**

8. PR√ìXIMOS PASOS REQUERIDOS
=============================

üöÄ ACCIONES INMEDIATAS:
=======================

1. **Modificar get_tournee_data()** para hacer petici√≥n HTTP real
2. **Implementar env√≠o de token** en headers de autorizaci√≥n
3. **Agregar headers faltantes** (Accept-Encoding, Connection)
4. **Usar User-Agent de browser** en lugar de "DeliveryRouting/1.0"
5. **Implementar endpoint real** de tourn√©e de Colis Priv√©

üîß IMPLEMENTACI√ìN REQUERIDA:
============================

```rust
// En get_tournee_data(), despu√©s de obtener el token:
let tournee_url = "https://wstournee-v2.colisprive.com/WS-TourneeColis/api/getBeanInfoDashBoardBySocieteMatriculev2/";

let tournee_payload = json!({
    "Societe": request.societe,
    "Matricule": request.matricule,
    "DateDebut": request.date,
    "Agence": None,
    "Concentrateur": None
});

let tournee_response = reqwest::Client::new()
    .post(tournee_url)
    .header("Accept", "application/json, text/plain, */*")
    .header("Accept-Encoding", "gzip, deflate, br, zstd")
    .header("Accept-Language", "fr-FR,fr;q=0.5")
    .header("Cache-Control", "no-cache")
    .header("Connection", "keep-alive")
    .header("Content-Type", "application/json")
    .header("Origin", "https://gestiontournee.colisprive.com")
    .header("Referer", "https://gestiontournee.colisprive.com/")
    .header("SsoHopps", &auth_response.token.unwrap()) // üîë TOKEN CR√çTICO
    .header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36")
    .json(&tournee_payload)
    .send()
    .await?;
```

9. RESUMEN DEL ESTADO ACTUAL
============================

üìä AN√ÅLISIS COMPLETO:
======================

‚úÖ **LO QUE FUNCIONA PERFECTAMENTE:**
1. Backend funcionando y accesible
2. Comunicaci√≥n con Colis Priv√© establecida
3. Autenticaci√≥n exitosa con headers correctos
4. Token obtenido correctamente
5. Estructura de respuesta procesada

‚ùå **LO QUE FALLA CR√çTICAMENTE:**
1. Endpoint tourn√©e no implementa petici√≥n HTTP real
2. Token no se usa para autorizaci√≥n
3. Headers de autorizaci√≥n no se env√≠an
4. Respuesta es mock, no datos reales
5. Falta implementaci√≥n del flujo completo

üéØ **PROBLEMA RA√çZ IDENTIFICADO:**
La funci√≥n get_tournee_data() est√° incompleta y no implementa la petici√≥n HTTP real a Colis Priv√© para obtener tourn√©e.

üîß **SOLUCI√ìN REQUERIDA:**
Implementar la petici√≥n HTTP real en get_tournee_data() con headers de autorizaci√≥n y token correcto.

---
Fin del reporte - An√°lisis del c√≥digo backend completado el 28/08/2025
